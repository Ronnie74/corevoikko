#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2006 - 2010 Harri Pitk√§nen (hatapitk@iki.fi)
# Test program for Voikko.
# This program requires Python and Python interface to libvoikko.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import sys
import locale
import codecs
import os
import subprocess
import getopt
import voikkoutils
from libvoikko import Voikko
from libvoikko import SuggestionStrategy

SVNROOT = voikkoutils.get_preference('svnroot')
WORKSPACE = voikkoutils.get_preference('voikkotest_dir')
THREADS = voikkoutils.get_preference('voikkospell_threads')
VARIANT = voikkoutils.get_preference('language_variant')
BUILD_OPTIONS = voikkoutils.get_preference('voikkotest_build_options')
ENCODING = voikkoutils.get_preference('encoding')
HYPHENCMD = voikkoutils.get_preference('libvoikko_bin') + '/voikkohyphenate'
SPELLCMD = voikkoutils.get_preference('libvoikko_bin') + '/voikkospell'
GCCMD = voikkoutils.get_preference('libvoikko_bin') + '/voikkogc'
DIFFVIEWCMD = voikkoutils.get_preference('diffviewcmd')
SM_DESTDIR = voikkoutils.get_preference('voikkotest_sm_destdir')

langcode = "fi_FI"
spelltest = SVNROOT + "/trunk/tests/voikkotest/spell.txt"
hyphentest = SVNROOT + "/trunk/tests/voikkotest/hyphen.txt"
suggesttest = SVNROOT + "/trunk/tests/voikkotest/suggest.txt"
GRAMMARTESTFILE = SVNROOT + "/trunk/tests/voikkotest/grammar.txt"
MORPHOTESTFILE = SVNROOT + "/trunk/tests/voikkotest/morpho.txt"
BASE = WORKSPACE + "/base"
WORDLIST = WORKSPACE + "/wordlist.txt.gz"
BASE_CORRECT = WORKSPACE + "/base-correct.txt"
BASE_INFO = WORKSPACE + "/base-info.txt"
CURRENT_CORRECT = WORKSPACE + "/current-correct.txt"
SMV = SVNROOT + "/trunk/suomimalaga"

# Returns a list of hyphenated words. Wordlist is a list of words to hyphenate and
# params is a string containing the parameters for HYPHENCMD
def _hyphenate_wordlist(wordlist, params):
	hyphenator = subprocess.Popen(HYPHENCMD + " " + params, shell = True,
	    stdin = subprocess.PIPE, stdout = subprocess.PIPE, close_fds = True)
	for word in wordlist:
		hyphenator.stdin.write(word.encode('UTF-8') + '\n')
	(out, err) = hyphenator.communicate()
	rawlist = out.split('\n')
	hyphenatedlist = []
	for hword in rawlist:
		hyphenatedlist.append(unicode(hword, 'UTF-8'))
	return hyphenatedlist #FIXME: last item is an extra empty string


def _check_hyphens(section, expected_results, results):
	failcount = 0
	for i in range(0, len(expected_results)):
		if expected_results[i] != results[i]:
			print u'Hyphenation test failed in section "%s":' % section
			print u'  Expected "%s", got "%s"' % (expected_results[i], results[i])
			failcount = failcount + 1
	return failcount

def _check_gcerrors(inputpara, expresults, results):
	failcount = 0
	for i in range(0, len(expresults)):
		if len(results) - 1 < i:
			print u'Grammar test failed: less results than expected.'
			print u'The first paragraph with missing results:'
			print u' ' + inputpara[i]
			return failcount + 1
		if expresults[i] != results[i]:
			print u'Grammar test failed. Input:'
			print u' ' + inputpara[i]
			print u'Expected results:'
			for r in expresults[i]: print u' ' + r
			print u'Actual results:'
			for r in results[i]: print u' ' + r
			failcount = failcount + 1
	return failcount

# Returns a list of grammar errors.
def _check_grammar(paragraphlist, params, voikko):
	for param in params.split(u" "):
		if len(param) > 0:
			eval(param)
	paragrapherrors = []
	for paragraph in paragraphlist:
		errorStrings = []
		for error in voikko.grammarErrors(paragraph):
			errorStrings.append(error.toString())
		paragrapherrors.append(errorStrings)
	setDefaults(voikko)
	return paragrapherrors

# Ensure that the current version is up to date
def update_smv():
	if os.system('cd "%s" && make voikko %s' % (SMV, BUILD_OPTIONS)) != 0:
		sys.stderr.write(u"Failed to compile new version of Suomi-malaga.\n")
		sys.exit(1)
	if SM_DESTDIR is not None:
		if os.system('cd "%s" && make voikko-install DESTDIR="%s"' % (SMV, SM_DESTDIR)) != 0:
			sys.stderr.write(u"Failed to install new version of Suomi-malaga.\n")
			sys.exit(1)

# Run "make clean"
def clean_smv():
	if os.system('cd "%s" && make clean' % SMV) != 0:
		sys.stderr.write(u'Failed to run "make clean"\n')
		sys.exit(1)

# Run the spelling tests
def spell_tests(voikko):
	try:
		inputfile = codecs.open(spelltest, "r", ENCODING)
		testcount = 0
		failcount = 0
		linecount = 0
		section = u"(none)"
		negativeTest = False
		while True:
			line_orig = inputfile.readline()
			linecount = linecount + 1
			if line_orig == u'': break
			line = line_orig.strip()
			commentstart = line.find(u"#")
			if commentstart != -1: line = line[:commentstart].strip()
			if line.startswith(u'[') and line.endswith(u']'):
				section = line[1:-1]
				continue
			if line.startswith(u'!'):
				negativeTest = True
				word = line[1:]
			else:
				negativeTest = False
				word = line
			if len(word) == 0:
				continue
			testcount = testcount + 1
			wordOk = voikko.spell(word)
			if (not wordOk and not negativeTest) or (wordOk and negativeTest):
				print u'Spelling test failed at line %i, section "%s":\n  %s' \
				      % (linecount, section, line_orig)
				failcount = failcount + 1
		inputfile.close()
		if failcount == 0:
			print u"All %i spelling tests were successful." % testcount
			return True
		else:
			print u"%i out of %i spelling tests failed." % (failcount, testcount)
			return False
	except IOError:
		sys.stderr.write("Could not read from file " + spelltest + "\n")
		sys.exit(1)

# Run the hyphenator tests
def hyphen_tests():
	try:
		inputfile = codecs.open(hyphentest, "r", ENCODING)
		testcount = 0
		failcount = 0
		section = u"(none)"
		inputwords = []
		expresults = []
		while True:
			line_orig = inputfile.readline()
			if line_orig == u'': break
			line = line_orig.strip()
			commentstart = line.find(u"#")
			if commentstart != -1: line = line[:commentstart].strip()
			if line.startswith(u'[') and line.endswith(u']'):
				if len(inputwords) > 0:
					results = _hyphenate_wordlist(inputwords, section)
					failcount = failcount + _check_hyphens(section, expresults, results)
					inputwords = []
					expresults = []
				section = line[1:-1]
				continue
			parts = line.split()
			if len(parts) == 0: continue
			inputwords.append(parts[0].strip())
			expresults.append(parts[1].strip())
			testcount = testcount + 1
		inputfile.close()
		if len(inputwords) > 0:
			results = _hyphenate_wordlist(inputwords, section)
			failcount = failcount + _check_hyphens(section, expresults, results)
		if failcount == 0:
			print u"All %i hyphenation tests were successful." % testcount
			return True
		else:
			print u"%i out of %i hyphenation tests failed." % (failcount, testcount)
			return False
	except IOError:
		sys.stderr.write("Could not read from file " + hyphentest + "\n")
		sys.exit(1)

def read_nonempty(inputfile):
	while True:
		line = inputfile.readline()
		if line == u"": return u""
		commentstart = line.find(u"#")
		if commentstart != -1: line = line[:commentstart]
		line = line.strip()
		if len(line) > 0: return line

# Run grammar tests
def grammar_tests(voikko):
	try:
		inputfile = codecs.open(GRAMMARTESTFILE, "r", ENCODING)
		testcount = 0
		failcount = 0
		section = u""
		inputpara = []
		expresults = []
		line = read_nonempty(inputfile)
		while True:
			if line == u'': break
			if line.startswith(u'{') and line.endswith(u'}'):
				if len(inputpara) > 0:
					results = _check_grammar(inputpara, section, voikko)
					failcount = failcount + _check_gcerrors(inputpara, expresults, results)
					inputpara = []
					expresults = []
				section = line[1:-1]
				line = read_nonempty(inputfile)
				continue
			if len(line) == 0:
				line = read_nonempty(inputfile)
				continue
			testcount = testcount + 1
			inputpara.append(line)
			expresult = []
			while True:
				line = read_nonempty(inputfile)
				if line == u'': break
				if line[0] != u'[': break
				expresult.append(line)
			expresults.append(expresult)
		inputfile.close()
		if len(inputpara) > 0:
			results = _check_grammar(inputpara, section, voikko)
			failcount = failcount + _check_gcerrors(inputpara, expresults, results)
		if failcount == 0:
			print u"All %i grammar tests were successful." % testcount
			return True
		else:
			print u"%i out of %i grammar tests failed." % (failcount, testcount)
			return False
	except IOError:
		sys.stderr.write("Could not read from file " + GRAMMARTESTFILE + "\n")
		sys.exit(1)

def setDefaults(voikko):
	voikko.setIgnoreDot(False)
	voikko.setIgnoreNumbers(False)
	voikko.setSuggestionStrategy(SuggestionStrategy.TYPO)
	voikko.setAcceptTitlesInGc(False)
	voikko.setAcceptUnfinishedParagraphsInGc(False)
	voikko.setAcceptBulletedListsInGc(False)

# Run suggestion tests
def suggestion_tests(voikko):
	try:
		inputfile = codecs.open(suggesttest, "r", ENCODING)
		testcount = 0
		failcount = 0
		section = u""
		while True:
			line_orig = inputfile.readline()
			if line_orig == u'': break
			line = line_orig.strip()
			commentstart = line.find(u"#")
			if commentstart != -1: line = line[:commentstart].strip()
			if line.startswith(u'[') and line.endswith(u']'):
				section = line[1:-1]
				continue
			parts = line.split(u'\t')
			if len(parts) < 2: continue
			testcount = testcount + 1
			for option in section.split(u" "):
				if len(option) > 0:
					eval(option)
			suggestions = voikko.suggest(parts[0])
			setDefaults(voikko)
			for expresult in parts[1:]:
				if expresult.startswith(u'!'):
					if expresult[1:] in suggestions:
						print u'Suggestion test failed for "%s" in section [%s]: ' \
						u'"%s" not expected.' % (parts[0], section, expresult[1:])
						failcount = failcount + 1
				else:
					if not expresult in suggestions:
						print u'Suggestion test failed for "%s" in section [%s]: ' \
						u'"%s" expected.' % (parts[0], section, expresult)
						failcount = failcount + 1
					else:
						i = suggestions.index(expresult)
						suggestions = suggestions[i+1:]
		inputfile.close()
		if failcount == 0:
			print u"All %i suggestion tests were successful." % testcount
			return True
		else:
			print u"%i failures in %i suggestion tests." % (failcount, testcount)
			return False
	except IOError:
		sys.stderr.write("Could not read from file " + suggesttest + "\n")
		sys.exit(1)

def containsMorphoAnalysis(expectedAnalysis, actualAnalyses):
	for actualAnalysis in actualAnalyses:
		match = True
		for (key, value) in expectedAnalysis.iteritems():
			if not key in actualAnalysis or actualAnalysis[key] != value:
				match = False
				break
		if match:
			return None
	return u"Did not produce expected analysis:\n expected=%s\n actual=%s" \
	       % (expectedAnalysis, actualAnalyses)

def diffMorphoAnalyses(expectedAnalyses, expectedAnalysesCount,
	                   forbiddenKeys, actualAnalyses):
	if expectedAnalysesCount != None and \
	   len(actualAnalyses) != expectedAnalysesCount:
		return u"Expected %i analyses, got %i." % \
		       (expectedAnalysesCount, len(actualAnalyses))
	for expectedAnalysis in expectedAnalyses:
		result = containsMorphoAnalysis(expectedAnalysis, actualAnalyses)
		if result != None:
			return result
	for forbiddenKey in forbiddenKeys:
		for actualAnalysis in actualAnalyses:
			if forbiddenKey in actualAnalysis:
				return u"Analysis contained forbidden key %s." % forbiddenKey
	return None

# Run morphological analysis tests
def morpho_tests(voikko):
	try:
		inputfile = codecs.open(MORPHOTESTFILE, "r", ENCODING)
		testcount = 0
		failcount = 0
		linecount = 0
		word = None
		expectedAnalysesCount = None
		expectedAnalyses = []
		forbiddenKeys = []
		currentExpected = {}
		actualAnalyses = []
		while True:
			line_orig = inputfile.readline()
			linecount = linecount + 1
			if line_orig == u'':
				break
			line = line_orig.strip()
			commentstart = line.find(u"#")
			if commentstart != -1:
				line = line[:commentstart].strip()
			if line == u'':
				continue
			elif line.startswith(u'word:'):
				testcount = testcount + 1
				if currentExpected != {}:
					expectedAnalyses.append(currentExpected)
				error = diffMorphoAnalyses(expectedAnalyses,
				        expectedAnalysesCount, forbiddenKeys, actualAnalyses)
				if error != None:
					print u'Morphological test failed for word "%s":\n%s\n' \
						% (word, error)
					failcount = failcount + 1
				word = line[5:]
				actualAnalyses = voikko.analyze(word)
				expectedAnalyses = []
				forbiddenKeys = []
				expectedAnalysesCount = None
				currentExpected = {}
			elif line.startswith(u'expected:'):
				expectedAnalysesCount = int(line[9:])
			elif line.startswith(u'!'):
				forbiddenKeys.append(line[1:])
			elif line.startswith(u'analysis'):
				expectedAnalyses.append(currentExpected)
				currentExpected = {}
			else:
				key = line[:line.find(u'=')]
				value = line[line.find(u'=')+1:]
				currentExpected[key] = value
		if currentExpected != {}:
					expectedAnalyses.append(currentExpected)
		error = diffMorphoAnalyses(expectedAnalyses,
		        expectedAnalysesCount, forbiddenKeys, actualAnalyses)
		if error != None:
			print u'Morphological test failed for word "%s":\n%s\n' \
				% (word, error)
			failcount = failcount + 1
		inputfile.close()
		if failcount == 0:
			print u"All %i morphological tests were successful." % testcount
			return True
		else:
			print u"%i out of %i morphological tests failed." % (failcount, testcount)
			return False
	except IOError:
		sys.stderr.write("Could not read from file " + MORPHOTESTFILE + "\n")
		sys.exit(1)


# Run tokenizer tests
def tokenizer_tests():
	testfile = SVNROOT + "/trunk/tests/tokenizer/input.txt"
	resultfile = WORKSPACE + "/tokenizer.txt"
	expresults = SVNROOT + "/trunk/tests/tokenizer/output.txt"
	sys.stderr.write("Testing next_token functions...\n")
	os.system('cat "%s" | "%s" --tokenize > "%s"' % (testfile, GCCMD, resultfile))
	os.system('diff -U 0 "%s" "%s"' % (expresults, resultfile))

# Run sentence tests
def sentence_tests():
	testfile = SVNROOT + "/trunk/tests/sentence/next-in.txt"
	resultfile = WORKSPACE + "/sentence-next.txt"
	expresults = SVNROOT + "/trunk/tests/sentence/next-out.txt"
	sys.stderr.write("Testing next_sentence_start functions...\n")
	os.system('cat "%s" | "%s" --split-sentences > "%s"' % (testfile, GCCMD, resultfile))
	os.system('diff -U 0 "%s" "%s"' % (expresults, resultfile))

# START OF MAIN PROGRAM

# Read command line options
(opts, args) = ([], [])
try:
	(opts, args) = getopt.getopt(sys.argv[1:], "", ["base", "current", "compare"])
except getopt.GetoptError:
	sys.stderr.write("Usage: voikkotest           (run only developer tests)\n")
	sys.stderr.write("Usage: voikkotest --base    (create baseline from current version)\n")
	sys.stderr.write("Usage: voikkotest --current (create new 'current' for comparison)\n")
	sys.stderr.write("Usage: voikkotest --compare (compare current version against the baseline)\n")
	sys.exit(1)

if "--base" in [opt[0] for opt in opts]:
	if os.system('cd "%s" && make voikko-install DESTDIR="%s"' % (SMV, BASE)) != 0:
		sys.stderr.write(u"Failed to create baseline version.\n")
		sys.exit(1)
	sys.stderr.write("Running voikkospell on full wordlist...\n")
	os.system('bash -c \'time zcat "%s" | "%s" -j %i -p "%s" | grep "^C:" > "%s"\'' % \
	          (WORDLIST, SPELLCMD, THREADS, BASE, BASE_CORRECT))
	sys.exit(0)

if "--current" in [opt[0] for opt in opts]:
	clean_smv()
	update_smv()
	voikko = Voikko()
	if not spell_tests(voikko):
		sys.stderr.write("Some of the basic tests failed, fix this before using --current again!\n")
		sys.exit(1)
	voikko.terminate()
	sys.stderr.write("Running voikkospell on full wordlist...\n")
	os.system('bash -c \'time zcat "%s" | "%s" -j %i -p "%s" | grep "^C:" > "%s"\'' % \
	          (WORDLIST, SPELLCMD, THREADS, BASE, CURRENT_CORRECT))
	diffcmd = 'diff -U0 "%s" "%s" | ' % (BASE_CORRECT, CURRENT_CORRECT)
	new_accept = int(os.popen('%s grep ^+C: | wc -l' % diffcmd).read())
	old_accept = int(os.popen('%s grep ^-C: | wc -l' % diffcmd).read())
	if new_accept == 0 and old_accept == 0:
		sys.stderr.write("No changes\n")
		sys.exit(0)
	sys.stderr.write("%s previously rejected strings are now accepted.\n" % new_accept)
	sys.stderr.write("%s previously accepted strings are now rejected.\n" % old_accept)

if "--compare" in [opt[0] for opt in opts]:
	os.system(DIFFVIEWCMD % (BASE_CORRECT, CURRENT_CORRECT))

else:
	update_smv()
	voikko = Voikko(variant = VARIANT)
	spell_tests(voikko)
	suggestion_tests(voikko)
	morpho_tests(voikko)
	hyphen_tests()
	grammar_tests(voikko)
	tokenizer_tests()
	sentence_tests()
	voikko.terminate()
